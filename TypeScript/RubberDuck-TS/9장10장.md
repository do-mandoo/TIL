# 9.프론트엔드 프레임워크와 백엔드 프레임워크
9-1. 프론트엔드 프레임워크
  - 리액트
    - JSX입문
    - TSX = JSX + 타입스크립트
    - 리액트에서 TSX 사용하기
  - 앵귤러
    - 준비작업
    - 컴포넌트
    - 서비스
9-2. 타입 안전 API
9-3. 백엔드 프레임워크

# 10.Namespaces.Modules
10-1. 가볍게 살펴보는 자바스크립트 모듈의 역사
10-2. import, export
  - 동적 임포트
  - CommonJS와 AMD 코드 사용하기
  - 모듈 모드 VS. 스크립트 모드
10-3. 네임스페이스
  - 충돌
  - 컴파일된 출력
10-4. 선언 합치기
---
## 1. 9장 
### 프론트엔드 프레임워크
서론: 필요한 응용 프로그램을 직접 만들 수는 있지만 실제로 그렇게 하는 일은 드물다. 백엔과 프엔 사이에서 해결해야할 어려움을 다른 개발자들이 이미 해결해뒀기때문에 이들이 개발해둔 도구, 라이브러리, 프레임워크를 이용해서 프엔과 백엔을 개발한다면, 응용프로그램을 더 빠르고 안정적으로 만들 수 있다.<br/>
<br/>
목표 : 클라이언트와 서버 문제를 해결하는 도구 중 가장 인기있는 몇가지 프레임워크와 도구를 살펴보고, 프레임워크로 무엇을 할 수 있는지와 어떻게 안전하게 타입스크립트 응용 프로그램에 통합 할 수 있는지 공부한다.<br/>

- 리액트.
타입 안전성과 관련해서는 탁월한 선택. 컴포넌트 정의와 소비자 모두 타입을 검사한다.
타입스크립트와 리액트로 뷰의 타입을 지정한다면 프엔 개발팀의 생산성 두배향상~~
  - JSX 입문.
    - jsx없이도 리액트 사용가능.
    - 리액트 없이도 jsx사용가능.
    - 두개를 같이 사용하면 훨씬 안전한 뷰를 만들 수 있음.

  - TSX = JSX + TypeScript.
    - jsx지시어는 세가지 모드를 지원한다.
        1. react
          - JSX 지시문(pragma)에 따라 JSX를 .js 파일로 컴파일한다.(기본값은 React.createElement)
        2. react-native
          - 컴파일 하지 않고 JSX를 보존하며, .js확장자의 파일을 생성한다.
        3. preserve
          - JSX의 타입을 검사하지만 컴파일하지는 않으며 .jsx확장자의 파일을 생성한다.

    - 내부적으로 타입스크립트는 TSX타입을 넣고 뺄 수 있는 몇가지 후크(hook)을 제공한다.

  - 리액트에서 TSX 사용하기.
    - 사용 이유
      1. IDE를 더욱 더 적극적으로 활용가능(자동완성, 타입확인)
        - 리덕스와 함께 사용하게되면 connect로 통해서 props로 전달해줄때도 자동완성이 되서 굉장히 편리함.
      2. 실수 방지
    - 두 가지 컴포넌트(함수, 클래스) 선언 가능.
      - 책의 코드 해봤는데 자꾸 에러 남.. 뭐지?ㅠ
- 앵귤러
  - CLI.
  - 리액트보다 기능이 풍부한 프엔 프레임워크. 태생적으로 타입스크립트로 동작하도록 만들어짐.

### 타입 안전 API
- 프엔과 백엔 사이의 인터페이스에서 타입을 지정하는 법.
- 237쪽 '타입 안전 프로토콜'에서처럼 타입 안전성을 제공하는 프로토콜을 직접 개발하는 방법이 있다.
- 스웨거, gRPC, GraphQL 등의 도구로 API에 타입 안전성을 추가할 수 있다.

### 백엔드 프레임워크
- TypeORM으로 데이터베이스와 안전하게 상호작용할 수 있다.

## 2. 10장
- 목표
  - 코드에 네임스페이스와 모듈화를 적용하는 다양한 방법
  - 코드를 임포트하고 익스포트하는 방법
  - 코드의 크기가 커지면서 이런 기법을 확장하는 방법
  - 모듈 모드 vs. 스크립트 모드
  - 선언 합치기의 뜻과 활용 방법
### 가볍게 살펴보는 자바스크립트 모듈의 역사
- 모듈은 캡슐화가 잘 되어야 한다. 그렇지않으면, 의존성을 확보하는 과정에서 페이지가 망가질 수 있다.
- 모듈 간의 의존성은 명시적이어야 한다. 그렇지않으면, 한 모듈에 어떤 모듈이 필요하며 어떤 순서로 로딩해야 하는지 알 수 없기 때문이다.
- 모든 모듈은 앱 내에서 고유 식별자를 가져야 한다. 그렇지않으면, 어떤 모듈을 로딩해야하는지 안정적으로 지정할 수 없다.

### import,export
- ES2015는 export default를 지원한다.
- 동적 임포트














