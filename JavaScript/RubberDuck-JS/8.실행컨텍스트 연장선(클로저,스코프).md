# 실행 컨텍스트의 클로저와 스코프.

## 1. 클로저
### 1-1. 렉시컬 스코프 - Lexical Environment
자바스크립트 엔진은 어디서 호출했는지가 아니라, <br/>
함수를 **어디에 정의(선언)** 했는지에 따라 생성되고, **상위 스코프를 결정** 한다.<br/>
이를 렉시컬 스코프(정적 스코프)라 한다.
```javascript
const a = 1;
function x(){
  const a = 2;
  function y(){
    console.log(a); // 2
  }
  y();
}
x();
```
위의 코드일때, 함수x는 전역에 정의한 전역함수이고, 함수y는 함수x에서 정의한 중첩된 함수이면서, 함수x의 지역함수이다.<br/>
y함수의 상위 스코프는 x함수이고, x함수의 상위스코프는 전역이다.<br/>
전역의 상위스코프는 전역이 끝이기때문에 참조하면 null을 반환한다.<br/>
<br/>
실행컨텍스트에서 공부했듯이 스코프의 실체는 실행 컨텍스트의 렉시컬 환경(Lexical environment)이다. <br/>
이 렉시컬 환경은 자신의 "외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Refernce)"를 통해 상위 렉시컬 환경과 연결된다.<br/>

이것이 바로 **스코프 체인** 이다.<br/>
<br/>

### 1-2. 함수 객체의 내부 슬롯 [[Environment]]
렉시컬 스코프가 가능하려면 함수는 자신이 호출되는 환경과는 상관없이 자신이 정의된 환경, 즉 상위 스코프(함수 정의가 위치하는 스코프가 상위 스코프다.)를 기억해야한다.
이를 위해 함수는 자신의 내부슬롯`[[Environment]]`에 자신이 정의된환경인 상위스코프의 참조를 저장한다.<br/>
<br/>

함수 정의가 평가되어 함수 객체를 생성할 때, 함수객체자신의 내부슬롯 `[[Environment]]`에 상위 스코프의 참조를 저장한다. 상위 스코프의 참조= 현재 실행중인 실행 컨텍스트의 렉시컬 환경을 가리킨다.<br/>
<br/>

**자신이 호출되었을 때 생성될 함수 렉시컬환경의 "외부 렉시컬 환경에 대한 참조"에 저장될 참조값이다.**

```javascript
const x = 1;

function foo(){
  const x = 10;

  bar();
}

function bar(){
  console.log(x); 
}
foo(); // ? -> 1
bar(); // ? -> 1
```
함수bar는 자신의 상위 스코프인 전역 렉시컬환경을 `[[Environment]]`에 저장해서 기억한다.


### 1-3. 클로저와 렉시컬 환경
```javascript
const x = 1;
function outer(){
  const x = 10;
  const inner = function(){console.log(x)};
  return inner
}
const FuncInner = outer();
FuncInner(); // 10
```
위 예제를 보면 outer()함수를 호출하면 outer함수는 중첩함수 inner를 반환하고 생명주기를 마감한다. 실행 컨텍스트 스택에서 pop된다.<br/>
outer함수가 제거되면서 내부의 지역변수x와 변수값10또한 생명주기를 마감해서 outer함수의 지역변수 x는 더는 유효하지않게되서 접근할 수 없어 보인다.<br/>
하지만 FuncInner()의 실행결과가 outer함수의 지역변수 x의 값인 10이다.<br/>
<br/>
이처럼 자신을 포함하고 있는 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 외부함수 밖에서 중첩함수를 호출하면 외부함수의 지역변수에 접근할 수 있다. 이러한 함수를 클로저라고 한다. 그리고 outer함수의 지역변수 x변수를 자유변수(free variable)라고 부른다.<br/>
<br/>
하지만 참조하지도 않는 식별자를 기억하는 것은 메모리 낭비이기 때문에 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지않는다. 따라서 클로저의 메모리 낭비를 줄여준다.<br/>

### 1-4. 클로저의 활용
클로저는 상태state를 안전하게 변경하고 유지하기 위해 사용한다. 상태를 안전하게 은닉(information hiding)하고 특정함수에게만 상태변경을 허용하기위해 사용한다.<br/>
<br/>

**즉시 실행 함수**
```javascript
// 카운트 상태 변경 함수를 즉시 실행함수로 만들기.
const increase = (function () {
  // 카운트 상태 변수
  let num = 0;

  // 클로저
  return function(){
    // 카운트 상태를 1만큼 증가시킨다.
    return ++num;
  };
}());

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```
즉시 실행 함수는 한 번만 실행되고 위의 코드에서는 호출된 이후 소멸한다. 그 안에서 반환한 클로저는 변수 increase에 할당되어 호출된다.<br/>
<br/>
num 변수가 재차 초기화 될일도, 외부에서 직접 접근할 수도 없는 은닉하게 되었다.<br/>


## 2. 스코프(scope, 유효범위) var키워드로 선언된 변수.
변수와 함수에 깊은 관련이 있다.
모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자인 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프라한다. 스코프는 식별자가 유효한 범위를 말한다.
<br/>
스코프의 종류는 전역(global)과 지역(local)으로 구분한다.<br/>
전역 변수는 어디서든지 참조할 수 있다. 함수 내부에서도 참조할 수 있다.<br/>
지역 변수는 자신의 함수 몸체 내부를 만든다. 지역 변수a에서 중첩된 함수b를 생성한다면 지역변수a의 스코프는 자신의 지역스코프a와 하위지역스코프b에서 유효하다.<br/>
<br/>

### 2-1. 스코프 체인
함수는 중첩 될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다.<br/>
스코프가 함수의 중첩에 의해 계층적 구조를 갖는다는 것을 뜻한다.<br/>
이러한 계층적 구조는부자 관계로 이루어진 상속(inheritance)과 유사하다.
<br/>
자바스크립트 엔진은 스코프 체인을 따라 변수를 참조한다.<br/>
선언된 식별자를 검색하는 방향은 하위스코프 -> 상위스코프 이다.<br/>
이는 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만, 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다는 것을 의미한다.<br/>
<br/>

### 2-2. 함수 레벨 스코프function level scope와 블록 레벨 스코프 block level scope
함수의 코드블록에서**만** 지역 스코프가 생성된다.<br/>
`if`, `for`, `while`, `try/catch`등 의 코드 블록은 지역 스코프를 만든다. 이러한 특성을 블록 레벨 스코프라고 한다.<br/>
하지만 `var`키워드로 선언된 변수는 **오로지** 함수의 코드블록(함수몸체)만을 지역스코프로 인정한다. 이러한 특성을 함수 레벨 스코프라고 한다.
```javascript
var x = 1;
let y = 2;
if(true){
  var x = 10;
  let y = 20;
}

console.log(x); // 10
console.log(y); // 2
```


- 말로 설명.
  - 스코프란? 유효범위를 뜻한다. 
    - 모든 식별자(변수 이름, 함수 이름, 클래스 이름)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. === 스코프는 식별자가 유효한 범위를 말한다. === 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙.
  - 클로저란? 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.
    - 자신을 포함하고 있는 외부 함수보다, 중첩 함수가 더 오래 유지되는 경우, 외부 함수 밖에서 중첩 함수를 호출하더라도, 외부함수의 지역변수에 접근할 수 있는 것을 클로저라 한다.

- 자바스크립트 엔진은 소스코드의 평가와 실행 과정으로 나눠서 처리합니다.
- 평가 과정에서는 실행컨텍스트를 생성하고/ 변수,함수등의 선언문만을 먼저 실행해서 생성된 변수나 함수 식별자를 키로/ 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록합니다.
- 평가과정이 끝나면 선언문을 제외한 소스코드 순차적으로 실행한다. === 런타임이 시작된다. 변수나 함수의 참조를 실행컨텍스트가 관리하는 스코프에서 검색해서 취득. 그리고 변수 값의 변경과 같은 소스코드의 실행 결과는 다시 실행컨텍스트가 관리하는 스코프에 등록된다.
  ```javascript
  var x;
  x = 1;

  //소스코드의 평가 x | undefined
  //소스코드의 실행 x | 1
  ```

- 다른 스코프에 동일한 이름의 식별자 여러개 있을 수 있어. 폴더 여러개에 같은 이름 파일 가능한것처럼. 폴더로 구분. 스코프로 구분. *식별자 결정(identifier resolution)*
- **식별자 결정** 을 위해 식별자를 검색할때, 실행중인 실행컨텍스트에서 식별자를 검색해. 왜냐면 선언된 식별자는 실행컨텍스트의 렉시컬환경(LE)의 환경레코드(ER)에 등록되어있으니까. 만약 ER에서 식별자를 검색할 수 없으면, 외부렉시컬환경에대한참조(OLER)가 가리키는 렉시컬환경인 상위스코프로 이동해서 식별자를 검색해. 이게 스코프체인의 동작원리입니다.

```javascript
var x = 1;
const y = 2;

function foo(a){
  var x = 3;
  const y = 4;
  const inner = function()(console.log(y));

  function bar(b){
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
  return inner;
}
foo(10)
foo()
```

- 전역객체는 전역코드 평가되기 이전에 생성된다.
- foo함수 호출 되었을때 foo함수 코드의 평가 순서
  1. 함수 실행 컨텍스트 생성 FEC
  2. 함수 렉시컬 환경 생성 FLE
      - 2-1. 함수 환경 레코드 생성 FER
      - 2-2. this바인딩 : 일반함수로 호출되어서 전역객체를 가리킴.
      - 2-3. 외부렉시컬환경에대한참조결정 OLER : 함수정의를 평가해서 생성될때 함수 객체의 내부슬롯[[Environment]]에는 함수의 상위스코프(=== 현재 실행중인 컨텍스트의 렉시컬 환경. //=== 해당 실행컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경)

클로저는 