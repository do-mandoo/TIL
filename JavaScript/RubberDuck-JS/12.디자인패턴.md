# MVC, MVP, MVVM, MVW 디자인 패턴 Design Pattern

## MVC(Model - View - Controller) 패턴
- MVC(Model - View - Controller)는 하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 개발 방법론 또는 패턴이다.
- 사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인패턴이다.
- 소프트웨어의 비즈니스로직과 화면을 구분하는데 중점을 두고 있다. === 각각의 역할을 나눠 코드관리를 한다.
- MVC에 기반을 둔 디자인 패턴들 
  - MVP(모델-뷰-프리젠터)
  - MVVM(모델-뷰-뷰 모델)
  - MVW(모델-뷰-왓에버)

### 동작 : 아래의 그림처럼 사용자가 Controller를 조작하면 -> Controller는 Model를 통해서 데이터를 가져오고 -> 그 정보를 바탕으로 시각적인 표현을 담당하는 View를 제어해서 -> 사용자에게 전달하게 된다.
![image-20210607101803830](C:\Users\부캐진\AppData\Roaming\Typora\typora-user-images\image-20210607101803830.png)

- Web MVC - 웹에 적용해보면
  1. 사용자가 웹사이트에 접속한다. - User
  2. Contoller는 사용자가 요청한 웹페이지를 서비스하기위해서 모델을 호출한다. - MainPulates
  3. 모델은 데이터베이스나 파일과 같은 데이터소스를 제어한 후에 그 결과를 리턴한다.
  4. Controller는 Model이 리턴한 결과를 View에 반영한다. - Updates
  5. 데이터가 반영된 View는 사용자에게 보여진다. - Sees

- 위의 그림은 하나의 로직을 설명하기위해 만든 그림이고, 사실 MVC패턴의 구조는 아래 그림이 더 어울릴 것이다. Controller가 View에도 영향을 미치는(화살표 봐) 부분이 있어야 한다.
![image-20210607112414413](C:\Users\부캐진\AppData\Roaming\Typora\typora-user-images\image-20210607112414413.png)

- 아래 그림을 보면서 MVC패턴이 뭔지 감을 잡자. 모델은 컨트롤러에, 컨트롤러는 뷰에, 뷰는 다시 유저에, 유저는 다시 컨트롤러를 향해서 간다.
![image-20210607112446322](C:\Users\부캐진\AppData\Roaming\Typora\typora-user-images\image-20210607112446322.png)


- 아래 그림은 클라이언트와 DB를 고려한 일반적인 MVC 패턴의 대표적인 예시이다.
- 사용자가 애플리케이션에 어떤 요청을 하는 순간부터 서버가 응답하기까지의 흐름/동작은 다음과 같다.
  1. 브라우저가 페이지를 조회하기 위해 url을 입력하거나 링크를 클릭함. - 요청을 보냄
  2. 라우터에서 url을 받아 Controller로 연결시킨다.
  3. Controller에서는 응답을 보내기 위한 로직을 처리한다.
    	1. 데이터가 필요하다면 Model에서 데이터를 조회한다. - 쿼리를 통해DB에서 데이터조회
    	2. 어떤 페이지를 사용자에게 보여줄지 렌더링을 해서 데이터와 함께HTML문서를 응답한다.
![image-20210607124029250](C:\Users\부캐진\AppData\Roaming\Typora\typora-user-images\image-20210607124029250.png)

- MVC패턴을 표현한 다양한 벤다이어그램.
![image-20210607111915283](C:\Users\부캐진\AppData\Roaming\Typora\typora-user-images\image-20210607111915283.png)
![image-20210607111951802](C:\Users\부캐진\AppData\Roaming\Typora\typora-user-images\image-20210607111951802.png)


### MVC 패턴의 구조
1. 모델(Model) : 데이터와 비즈니스 로직을 관리.  일반적으로 CI의 모델은 데이터베이스 테이블에 대응된다. 이를테면 Topic이라는 테이블은 topic_model이라는 Model을 만든다. 그런데 이 관계가 강제적이지 않기 때문에 규칙을 일관성있게 정의하는것이 필요하다. 
   - 데이터, 알고리즘, DB 등을 Model이라고하는데, App이 "무엇"을 처리할 것인지 정의. === 어떻게 보일지(View,Controller)에 대해 신경쓰지 않아도 된다.
   - 애플리케이션의 데이터를 의미하며, Database의 데이터를 조작하는 Layer다.
   - 애플리케이션의 정보, 데이터를 나타낸다. 데이터베이스, 처음의 정의하는 상수, 초기화값, 변수 등을 뜻한다. 또한 이러한 데이터, 정보들의 가공을 책임지는 컴포넌트를 말한다. 
   - 모델 규칙
    1. 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 한다.
       - 화면안의 네모박스에 글자가 표현된다면, 네모박스의 화면 위치 정보, 네모박스의 크기정보, 글자내용, 글자의 위치, 글자의 포맷 정보 등을 가지고 있어야한다.
   2. 뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야 한다.
      - 데이터 변경이 일어났을 때 모델에서 화면에 UI를 직접 조정해서 수정할 수 있도록 뷰를 참조하는 내부속성값을 가지면 안된다는 말이다.
   3. 변경이 일어나면, 변경 통지에 대한 처리방법을 구현해야만 한다.
      - 모델의 속성 중 텍스트 정보가 변경된다면, 이벤트를 발생시켜서 누군가에게 전달해야하며, 누군가 모델을 변경하도록 요청하는 이벤트를 보냈을 때 이를 수신할 수 있는 처리방법을 구현해야한다. 또한 모델은 재사용가능해야하며, 다른 인터페이스에서도 변하지 않아야 한다.
2. 뷰(View) : 레이아웃과 화면을 처리. 클라이언트 측 기술인 html/css/javascript들을 모아둔 컨테이너이다.
   - 사용자에게 보여줄 정보들을 Controller나 Model에서 가져와서 보여주고 입력을 받을 수 있도록 함. === 데이터 저장이나 로직을 신경쓰지않고 변경처리 이벤트에만 관심있다.
   - 사용자에게 보여지는 인터페이스를 의미하며, 웹에서는 HTML문서라고 생각하면 된다.
   - input테스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타냅니다. 다시 말해 데이터 및 객체의 입력과 보여주는 출력을 담당한다. 데이터 기반으로 사용자들이 볼 수 있는 화면이다.
   - 뷰의 규칙.
   1. 모델이 가지고 있는 정보를 따로 저장해서는 안된다.
      - 화면에 글자를 표시하기위해, 모델이 가지고있는 정보를 전달받게되는데, 그 정보를 유지하기위해서 임의의 뷰 내부에 저장하면 안된다. 단순히 네모 박스를 그리라는 명령을 받으면, 화면에 표시하기만하고, 그 화면을 그릴 때 필요한 정보들은 저장하지 않아야한다.
   2. 모델이나 컨트롤러와 같이 다른 구성요소들을 몰라야 된다.
      - 모델과 같이 자기 자신의 요소는 빼고 다른 요소는 참조하거나 어떻게 동작하는지 알아서는 안된다. 그냥 **뷰는 데이터를 받으면 화면에 표시해주는 역할만 가진다**고보면 된다.
   3. 변경이 일어나면 변경통지에 대한 처리방법을 구현해야만 한다.
      - 모델과 같이 변경이 일어났을 때, 이 변경을 누군가에게 알려줘야하는 방법을 구현해야한다. 뷰에서는 화면에서 사용자가 화면에 표시된 내용을 변경하게되면, 이를 모델에게 전달해서 모델을 변경해야할 것이다. 그 작업을 하기위해 변경통지를 구현한다.
      - 그리고 재사용가능하게 설계를 해야하며, 다른 정보들을 표현할때 쉽게 설계해야한다.
3. 컨트롤러(Controller) : 명령을 모델과 뷰 부분으로 라우팅.  사용자가 접근한 URL에따라서 사용자의 요청사항을 파악한 후에 그 요청에 맞는 데이터를 Model에 의뢰하고, 데이터를 View에 반영해서 사용자에게 알려준다.
   - Model이나 View의 요소들을 유저의 요청에 맞게 "어떻게" 처리할 것인지 정의. === 무엇을 처리할지나 보여줌에 있어서 신경쓰지 않는다.
   - 데이터(model)와 인터페이스(view)간의 상호동작을 관리한다. 즉, Model에 명령을 보내 데이터의 상태를 바꾸고, 어떤 화면을 사용자에게 보여줄지 View에 명령을 한다.
   - 데이터와 사용자인터페이스요소들을 잇는 다리역할을한다. 즉, 사용자가 데이터를 클릭하고 수정하는 것에 대한 "이벤트"들을 처리하는 부분을 뜻한다.
   - 컨트롤러 규칙.
    1. 모델이나 뷰에 대해서 알고 있어야 한다.
       - 모델이나 뷰는 서로의 존재를 모르고, 변경을 외부로 알리고, 수신하는 방법만 가지고 있는데, 이를 컨트롤러가 중재하기 위해 모델과 그에 관련된 뷰에 대해서 알고 있어야 한다.
   	2. 모델이나 뷰의 변경을 모니터링 해야 한다.
       - 모델이나 뷰의 변경통지를 받으면, 이를 해석해서 각각의 구성요소에게 통지를 해야한다. 또한, 애플리케이션의 메인로직은 컨트롤러가 담당하게 된다.
4. Client입장


### MVC패턴을 사용하는 이유
  - 역할 구분으로 서로 분리되어 각자의 역할에 집중할 수 있게해서 개발을 하고, 그렇게 애플리케이션을 만든다면, 유지보수성, 애플리케이션의 확장성, 그리고 유연성(유연성: 클라이언트의 새로운 요구사항에 대한 최소한의 비용으로 보다 유연하게 대처할 수 있는 것을 말함)이 증가하고, 중복코딩이라는 문제점 또한 사라지게 된다.
  - **View와 Model사이에 Controller를 두어 View와 Model의 의존성을 없애기 위함**이 **목적**이다. 훌륭한 설계란 **인터페이스간의 의존성(Dependency)를 제거**하는것에 있다.

### MVC 패턴을 사용하는 프레임워크나 라이브러리
  - AngularJS(구글), CodeIgniter(php),  django(python), React(facebook)
  - React는 MVC패턴만 사용하다가 redux의 flux패턴도 쓴다. React는 MVC프레임워크는 아니고, View만 신경쓰는 라이브러리다. 다른 웹프레임워크와 달리 ajax, 데이터 모델링, 라우팅 같은 것이 없다. 뷰만 신경쓴다. 또한 React는 단방향 데이터 흐름으로, 데이터 변경에 관한 DOM객체만 변경해주는 체계, 데이터가 변경되면 양방향 데이터 바인딩처럼 모델변경 -> 뷰변경이 아니라 특정함수를 실행시킴으로서 DOM객체를 갱신한다.

### MVC 특징 
  - MVC패턴은 결국 "어떻게 나눌 것인가" 에 대한 해답중 하나다. 어떤 특정한 역할들에대해 역할을 분담할때, 가이드라인을 제시하는 방법중 하나가 MVC패턴이다.
  - MVC 패턴은 의존성을 제거하기위해 고안된 디자인 패턴이지만, 실제로는서 View에서 Model을 이용하기때문에 Model이 업데이트 되면 View도 업데이트가 된다(Model과 View가 1:N관계로 매우 복잡해진다. === 의존성이 문제를 일으킬 확률이 올라간다). 따라서 V와 M의 의존성을 완벽히 분리하기 위해 새로운 패턴이 등장했다. (MVP)

---

## MVP(Model - View - Presenter) 패턴
![image-20210607143356120](C:\Users\부캐진\AppData\Roaming\Typora\typora-user-images\image-20210607143356120.png)

  - MVP모델은 MVC모델의 Controller가 Presenter로 바뀐 것이다.
  - Presenter는 View의 인스턴스를 갖고있으며, View에서 요청이 발생하면 이벤트에 따른 Model의 상태를 변경시킨다. 즉, 철저하게 View와 Model을 분리시키고, View와 Model사이에 다리역할을 수행한다.
  - MVC 패턴에서 사용자 입력이 컨트롤러로부터 왔다. 
  - MVP 패턴에서 사용자 입력이 View에서 발생한다.
  ### MVP 패턴의 구조
  1. 모델(Model) : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분.
  2. 뷰(View) : 사용자에게 보여지는 UI부분.
  3. 프레젠터(Presenter) : View에서 요청한 정보로 Model을 가공하여, View에 전달해주는 부분. View와 Model을 붙여주는 접착제같은 역할을 한다.

  ### 동작
  - View에서 요청이 발생하면 Presenter로 전달하고 Presenter에서는 그 이벤트에 따른 Model의 상태를 업데이트시킨다. === Model이 업데이트되면 Presenter에서는 그 결과를 다시 View에 전달하는 것.<br/>
        ===
  1. 사용자의 Action들은 View를 통해 들어온다.
  2. View는 데이터를 Presenter에 요청한다.
  3. Presenter는 Model에게 데이터 요청한다.
  4. Model은 Presenter에서 요청받은 데이터를 응답한다.
  5. Presenter는 View에게 데이터를 응답한다.
  6. View는 Presenter가 응답한 데이터를 이용해서 화면을 나타낸다.

  ### 특징
  - MVP패턴은 View와 Model간의 의존성을 분리시켰지만, View와 Presenter의 관계는 1:1이기 때문에 Presenter는 View와 의존성이 깊다. 
  - View와 Presenter간의 의존성 문제를 해결하기 위해 새로운 패턴이 등장.(MVVM)


---

## MVVM(Model - View - ViewModel) 패턴

![image-20210607143415079](C:\Users\부캐진\AppData\Roaming\Typora\typora-user-images\image-20210607143415079.png)

  - MVVM모델은 MVC모델의 Controller, MVP모델의 Presenter대신 ViewModel로 바뀐 모델이다.
	- ViewModel은 View를 나타내기 위한 Model이라고 이해하면 된다.
  ### MVVM 패턴의 구조
  - 모델(Model) : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분.
  - 뷰(View) : 사용자에게 보여지는 UI부분.
  - 뷰모델(View Model) : View를 표현하기 위해 만든 View를 위한 Model이다. View를 나타내주기위한 Model이자, View를 나타내기위한 데이터를 처리하는 부분이다.
  
  ### 동작
  - MVP모델과 같이 View에서 입력이 들어온다. 들어온 입력은 Command패턴을 통해 ViewModel에 명령을 내리고, ViewModel은 Model에게 필요한 데이터를 요청함. Model은 ViewModel에 필요한 데이터를 응답하고 Data Binding을 통해 ViewModel의 값이 변화하면 바로 View의 정보가 바뀌게 된다.<br/>
        ===
  1. 사용자의 Action들은 View를 통해 들어온다.
  2. View에 Action이 들어오면, Command패턴으로 View Model에 Action을 전달한다.
  3. View Model은 Model에게 데이터를 요청한다.
  4. Model은 View Model에게 요청받은 데이터를 응답한다.
  5. View Model은 응답받은 데이터를 가공해서 저장한다.
  6. View는 View Model과 Data Binding해서 화면을 나타낸다.

  ### 특징
  - Command와 Data Binding 두가지 패턴을 통해 View의 의존성을 끊었다. 이로써 View와 Model의 분리가 이루어졌고, MVP패턴의 문제점이 해결되었다.
  - View Model과 View는 1:n관계.
  - 만약 MVC를 얕게 아는 상태에서 적용하면 높은 확률로 Controller에 모든 Logic이 들어갈 가능성이 크다. 그럼 Controller의 할일이 불필요하게 많아지고, 필요에 따라서는 Model에 Logic과 메소드를 설정해 이를 분산시켜야한다(getter, setter, ...).


## MVW(Model - View - Whatever) 패턴
- 

## 결론
  - MVC패턴의 문제 해결 패턴-> MVP패턴의 문제 해결 패턴 -> MVVM패턴 이라고해서 MVVM패턴이 항상 좋고 옳지는 않다. 각 패턴마다 장단점이 있고, 프로젝트 규모에 따라 적절한 선택을 해야한다.

---

*참고* <br/>
(<br/>
  -https://velog.io/@ljinsk3/MVC-%ED%8C%A8%ED%84%B4<br/>
  -mvw(https://blog.xenomity.com/MVWModel-View-Whatever%EC%9D%98-%EC%9D%B4%ED%95%B4/)<br/>
)