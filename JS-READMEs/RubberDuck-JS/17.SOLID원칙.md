# SOLID원칙
- SRP(Single Resposibility Principle) 단일 책임 원칙 
- OCP(Open Close Principle) 개방 폐쇄 원칙
- LSP(Liskov Substitution Principle) 리스코브 치환 원칙
- ISP(Interface Segregation Principle) 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle) 의존성 역전 원칙

- SOLID란 **응집도는 높이고(High Cohesion)**, **결합도는 낮추는(Loose Coupling)** 고전 원칙을 객체 지향의 관점에서 5가지 원칙으로 재정립 한 것이라고 볼 수 있다.
  - `응집도` : 하나의 모듈 내부에 존재하는 구성 요소들. 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져서 재사용이나 기능/유지보수가 용이하다.
    - 일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스의 응집도가 더 높다. 모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 가장 높다.
  - `결합도` : 모듈(클래스)간의 상호 의존 정도로서 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정/유지보수가 용이하다. (aka의존성)
- 각 규칙들이 독립적으로 존재하는 것이 아닌, 유기적으로 서로 연결되어 있다.

## Single Resposibility Principle 단일 책임 원칙 
함수나 클래스는 한가지 기능만 수행해야 한다.<br/>
폴더로 추상화를 해보자. 사진파일은 사진폴더에, 음악파일은 음악폴더에, 영상파일은 동영상폴더에. 하지만 사진폴더에 여러개의 파일을 넣다보니 헷갈리기 시작한다.
그럼 사진폴더를 정리하자.(날짜별로, 테마별로 정리하는건 개인취향.)
그러나 다른 누군가가 날짜를 아무날짜로 변경하거나, 테마폴더의 이름을 다른이름으로 변경한다면 찾기 어려워진다.
- `단일 책임 원칙은 (크고 작은)책임을 적절하게 배치하면 된다.`
- React에서는 특히 컴포넌트를 분리할 때 `단일 책임 원칙`을 적용해야한다.

## Open Close Principle 개방 폐쇄 원칙
기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계되어야한다는 뜻.
OCP에서 중요한 것은 요구사항이 변경되었을 때, 코드에서 변경되어야하는 부분과 변경되지 않아야하는 부분을 명확하게 구분해서 변경되어야하는 부분을 유연하게 작성하는 것을 의미.
또한, 확장에는 유연하게 반응하고, 변경은 최소화하는것을 의미.
클래스를 변경하지 않고도 대상 클래스의 환경을 변경할 수 있는 설계가 되어야 한다. 이를 위해 Mock Stub등의 객체들이 사용되며, 특히 단위테스트에서 유용하게 사용된다.

## Liskov Substitution Principle 리스코브 치환 원칙
일반화관계에 대한 이야기. 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위를 수행할 수 있어야 한다는 의미.
LSP를 만족하면 프로그램에서 부모 클래스의 인스턴스 대신에 자식 클래스의 인스턴스로 대체해도 프로그램의 의미는 변화되지 않는다. 이를 위해 부모 클래스와 자식 클래스의 행위는 일관되어야 한다.
자식클래스가 부모클래스를 오버라이딩하거나 추가적인 기능을 통해 부모의 상태를 변경시키는 것은 LSP원칙을 위반하는 것.
LSP는 서브 클래스가 슈퍼 클래스의 책임을 무시하거나 재정의하지않고 확장만 수행한다는것을 의미함.

## Interface Segregation Principle 인터페이스 분리 원칙
클라이언트에서는 클라이언트 자신이 이용하지 않는 기능에는 영향을 받지 않아야한다.
인터페이스를 클라이언트에 특화되도록 분리시켜야한다는 설계원칙이라고 할수도 있다.
- ex) 복합기 - 복사하고싶은사람, 프린트하는사람, 팩스보내려는사람 각각이 다른 기능에 대해 영향을 받지 않는다.
- 이러한 기능을 제공하고 싶을때 사용되는 것이 ISP이고, 사용 방법은 범용의 인터페이스를 만드는것이 아니라 클라이언트에 특화된 인터페이스를 사용해야한다.
- ISP와 SRP는 동일한 문제에 대해 다른 해결책을 제시하고 있는 것과 비슷.
- 하나의 클래스가 기능이 비대하다면, 책임을 분할하는것이 SRP이고,
- 비대한 기능을 인터페이스로 분할하여 사용하는것이 ISP를 의미한다.
물론 책임을 적절히 분할하여 각각의 인터페이스를 사용한다면, 둘 다 충족하는것이지만 그렇지 않은 경우도 존재한다.

## Dependency Inversion Principle 의존성 역전 원칙
추상화에 의존해야지, 구체화에 의존하면 안된다.
객체지향 프로그래밍에서 객체는 서로 도움을 주고받으며 의존관계를 발생시킨다.
DIP는 그러한 의존관계를 맺을 때, 변화하기 쉬운것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 가이드라인을 제공하는 원칙이다.


