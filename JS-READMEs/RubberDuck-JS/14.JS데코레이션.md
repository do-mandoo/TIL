# 데코레이터 Decorator 

## 데코레이터란?
- 데코레이터 함수(또는 메서드)의 약자.
  - 데코레이터 자체는 함수인데, 이 데코레이터에 전달된 함수를 수정한 새 함수를 반환하는 것.
    - 항상 고차함수(high-order)이다.
- 정식기능은 아니고, 2020년 9월 ECMA metting에서 TC39의 표준화 절차를 진행 중이다.
  - 그 전까지는 Babel사용하면 된다.
- 가장 단순하게는 코드의 한 부분을 다른 코드로 감싸는 방법(= 장식)
- 정의 중에 클래스요소, 기타 JavaScript구문 양식에서 호출되는 함수, 잠재적으로 decorator가 반환한 새 값으로 래핑(또는 대체) 됨.

## 데코레이터 사용하는 이유
- JS에서 함수 구성이 이미 가능하지만 동일한 기술을 다른 코드(클래스나 클래스 속성)에 적용하는 것이 훨씬 어렵거나 불가능 => 데코레이터 제안은 이런 문제를 해결하는데 사용할 수 있다.
- 작성중인 코드의 실제 의도를 더 명확하게 파악 가능하다.
- 코드가 간결해지고 명확해진다.



## 데코레이터 사용 방법 예시 - 파이썬
- 파이썬의 데코레이터가 JS의 데코레이터보다 작동하는 방식이 더 단순하기 때문에, 데코레이터 작동(=동작)을 설명하기 좋다.
    ```python
    def cashify(fn):
      def wrap();
        print("$$$$")
        fn()
        print("$$$$")
      return wrap

    @cashify
    def sayHello():
      print("hello!")

    sayHello()
    # $$$$
    # hello!
    # $$$$
    ```
- 위 파이썬 코드의 `cashify`함수는 데코레이터이다. 데코레이터는 함수를 인자로 하고, 반환 값도 함수다.
- 파이썬의 파이(@)구문을 사용해서 데코레이터를 `sayHello`함수에 적용했다. 
    ```python
    # 데코레이터를 적용한 sayHello는 
    # 이 코드에서 정의한 sayHello와 본질적으로 같다.
    def sayHello():
      print("hello!")

    sayHello = cashify(sayHello)
    ```
- JS와 TS는 파이썬의 '파이(@)구문'을 사용해서 데코레이터를 클래스의 메서드와 속성에 적용하므로 시각적으로나, 구문적으로 비슷해 보이기 때문이다.

## 자바스크립트 데코레이터와 속성 설명자
- `파이썬의 데코레이터`는 장식하는 함수의 모든 인자를 전달받지만, `자바스크립트의 데코레이터`는 자바스크립트 객체의 작동 방식 때문에 정보가 조금 더 필요하다는 **차이점**이 있다.
    ```javascript
    // 자바스크립트의 객체는 속성(property)이 있고, 각 속성은 값을 가지고 있다.
    const oatmeal = {
      viscosity: 20, // 점성
      flavor: 'Brown Sugar Cinnamon'
    };
    ```
- 그러나 각 속성은 값 이외에도 화면 밖에 숨겨진 정보들이 있는데, 이런 정보들이 각 속성이 어떻게 작동할지를 정의한다. === `속성 설명자(property descriptor)`라고 한다.
    ```javascript
    //속성 설명자를 확인하는 방법 Object.getOwnPropertyDescriptor(objectName,propertyName) 사용
    console.log(Object.getOwnPropertyDescriptor(oatmeal,'viscosity'));
    /*
    {
      configurable: true,
      enumerable: true,
      value: 20,
      writable: true
    }
    */
    ```
- 위의 코드처럼 'viscosity'속성이 어떻게 동작하는지에 대한 자세한 사항을 얻을 수 있다. 자바스크립트는 이런 속성에 대한 몇 가지를 추적하고 관리한다.
  - 데이터 프로퍼티
    - `구성 가능(configurable)`: 속성 유형 변경, 객체에서 속성을 삭제할 수 있는지 결정함.
    - `열거 가능(enumerable)`: `Object.keys(otmeal)`를 호출하거나 `for`루프에서 사용할때처럼 객체의 속성을 열거할 때 속성을 표시할지 여부를 제어함.
    - `쓰기 가능(writable)`: 할당연산자(=)를 통해 속성값을 변경할 수 있는지 제어함.
    - `값(value)`: 접근할 때 표시되는 속성의 정적 값임. 속성 설명자 중에 유일하게 쉽게 볼 수 있고, 주로 우리가 관심을 두고 보는 부분. 함수를 포함한 모든 자바스크립트의 값이 올 수 있으며, **이 속성은 속성을 자신이 속한 객체의 메소드로 만든다.**
  - 접근자 프로퍼티
    - `get`: 정적인 `value`대신 반환 값을 전달하는 함수다.
    - `set`: 속성에 값을 할당할 때, 등호 오른쪽에 넣는 모든 것을 인자로 전달하는 특수 함수다.

- 자바스크립트에서는 ES5부터 이 속성설명자를 다룰 수 있는 API인 `Object.getOwnPropertyDescriptor`메서드 및 `Object.defineProperty()`메서드를 제공한다.
    ```javascript
    // 오트밀의 점성을 그대로 유지하려면 아래처럼 API를 사용해서 읽기 전용 속성으로 만들 수 있다.
    Object.defineProperty(oatmeal, 'viscosity',{
      writable: false, // 쓰기 가능 false를 줘서 읽기 전용으로 만듦.
      value: 20
    });

    // 'oatmeal.viscosity'를 다른 값으로 설정하면 조용히 실패하게 될 것이다.
    oatmeal.viscosity = 30;
    console.log(oatmeal.viscosity); // 20 
    ```
- 객체의 특정 속성의 설명자를 직접 수정하는 범용 `decorate`함수를 작성할 수도 있다.
    ```javascript
    function decorate(obj,property, callback){
      var descriptor = Object.getOwnPropertyDescriptor(obj, property);
      Object.defineProperty(obj,property,callback(descriptor));
    }
    
    decorate(oatmeal, 'viscosity', function(desc){
      desc.configurable = false;
      desc.writable = false;
      desc.value = 20;
      return desc;
    })
    ``` 

## 판자 위에 크라운 몰딩 추가하기-??
- 데코레이터 제안과 앞에서 살펴본 데코레이터의 다른점
    1. 데코레이터 제안은 일반 객체가 아니라 ECMAScript 클래스에서**만** 관심이 있다는 것
- porridge(죽, 오트밀죽)같은 간단한 클래스를 작성해보자
    ```javascript
    class Porridge{
      constructor(viscosity = 10){
        this.viscosity = viscosity;
      }

      stir(){
        if(this.viscosity > 15){
          console.log('This is pretty thick stuff.');
        }else{
          console.log('Spoon goes round and round');
        }
      }
    }

    class Oatmeal extends Porridge{
      viscosity = 20;
      constructor(flavor){
        super();
        this.flavor = flavor;
      }
    }
    ```
- `Porridge` 클래스를 상속받아서 오트밀을 표현했다. `Oatmeal`클래스의 기본 `viscosity`를 Porridge의 기본값보다 높게 설정하고 새로운 `flavor`특성을 추가했다. 또한 `viscosity`값을 재정의하기 위해 다른 ECMAScript제안인 **`클래스필드(Class field)`**를 사용했다.

- 우리는 다음과 같이 기존의 오트밀 한 접시를 다시 만들 수 있다.
    ```javascript
    const oatmeal = new Oatmeal('Brown Sugar Cinnamon');
    
    console.log(oatmeal) 
    /*
    Oatmeal{
      flavor: 'Brown Sugar Cinnamon',
      viscosity: 20
    }
    */
    ```
    - **<u>이제 ES6으로 만든 오트밀이 완성되었다.</u>** 지금부터 데코레이터를 작성해보자.

## 데코레이터 작성하는 법
- JS데코레이터 함수에는 세가지 인자가 전달된다.
    1. `target`: 현재 인스턴스 객체의 클래스.
    2. `key`: 데코레이터를 적용할 속성 이름(문자열).
    3. `descriptor`: 해당 속성의 설명자 객체.
- 데코레이터의 목적에 따라 내부의 동작이 결정된다. 객체의 메서드나 속성을 변경, 꾸미려면 새로운 속성 설명자를 반환해야한다.
    ```javascript
    // 속성을 읽기 전용으로 만드는 데코레이터 작성 방법
    function readOnly(target, key, descriptor){
      return{
        ...descriptor,
        writable: false
      };
    }
    ```
- 우리가 만들어 놓은 Oatmeal 클래스도 조금만 수정하면 가능하다.
    ```javascript
    class Oatmeal extends Porridge{
      @readOnly viscosity = 20;
      // (@readOnly를 속성 바로 윗 줄에 적어도 된다.)
      // 현재는 TypeScript에서만 가능

      constructor(flavor){
        super();
        this.flavor = flavor;
      }
    }
    ```
      - 이제 오트밀의 접착제와 같은 점성은 변경에 영향을 받지 않는다.













```javascript
const errorDecorator = function(fn){
  return function(...args){
    try{
      console.log('Running function: ' + fn.name);
      fn(...args)
    }catch(err){
      console.warn(err);
    }
  };
};
function parse(str){
  let obj = JSON.parse(str); // JSON.parse했을 때 str이 없으면 오류를 일으킨다.
  console.log(obj);
  return obj;
};
const parseError = errorDecorator(parse);
/* 
window console창에 parseError('')입력하면
Running function: parse 가 나오고 // 이 부분이 데코레이터 함수 동작한 부분?
SyntaxError가 발생한다. 문구 : Unexpected end of JSON input
*/
//---
const logDecorator = function(fn){
  return function(){
    console.log('exeuting function: ' + fn.name);
    console.time('fn'); // 함수가 실행되는 시간 사이에 몇 밀리초가 경과했는지 확인할 수 있다.
    let val = fn();
    console.timeEnd('fn');
    return val;
  }
}
```